给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的移动。

在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。

返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。



示例 1：

输入：S = "cba", K = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
示例 2：

输入：S = "baaca", K = 3
输出："aaabc"
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。

//解题思路：当K >= 2K>=2的时候,我们总是能取前KK个中第一个违反当前前KK个非递减字母序的字母放在最后面。也就是说经过若干次操作后。整个字母序列单调非递减。所以答案就是对SS进行排序。
当K = 1K = 1的时候。将这个字符串序列想象成一个环序列，将一个字母放到最后若干次等价于将这个字符串环中取一个起点作为新字符串的起点。这样的字符串有 | S | 个，OSO个，所以此时答案就是这 | S | OSO个字符串中字典序最小的那一个。
时间复杂度O(| S | ^ 2)O(OSO2)

#define dbg(x) cout << #x"=" << x << endl;
class Solution {
public:
	string orderlyQueue(string S, int K) {
		string ans = S;
		if (K > 1) sort(ans.begin(), ans.end());
		else {
			int sz = S.size();
			for (int i = 1; i < sz; ++i){
				string s = "";
				for (int j = 0; j < sz; ++j){
					s += S[(i + j) % sz];
				}
				ans = min(ans, s);
			}
		}
		return ans;
	}
};
