请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。
在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

示例 1:

输入 :
	s = "aa"
	p = "a"
输出 : false
 解释 : "a" 无法匹配 "aa" 整个字符串。
	  示例 2 :

  输入 :
	 s = "aa"
	 p = "a*"
 输出 : true
  解释 : 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。



//解题思路：
/*
* 方法1 回溯法
* . 匹配单个任意字符，
* * 匹配前一个字符的任意0个或多个，
* 模式p中不带*时，字符串s与模式p直接比较就行，
* 如果模式p带*，它会出现在一个字符的后面，
* 如果p的第2个字符是*，有两种可能，
* *匹配前一个字符0个或者*匹配前一个字符多个，
* 匹配0个时，s回溯与p从第三个字符开始下一轮比较，
* 匹配多个时，在满足s和p第1个字符配对的情况下,
* s从第2个字符开始与p重新一轮匹配，
* 如果p第2字符不是*，在满足s和p第1个字符配对的情况下,
* 等于是普通匹配，继续下一轮匹配即可。
* */

bool isMatch(std::string s, std::string p) {
	if (p.empty()) {
		return s.empty();
	}

	// p,s第一个字符是否匹配，相等或为 '.'
	bool first_match = (!s.empty() && (p[0] == s[0] || p[0] == '.'));

	// 从p的第2个字符开始，如果为 '*'
	if (p.size() >= 2 && p[1] == '*') {
		// 考虑 '*' 表示前面字符0次和多次的情况
		// 0次：s回溯与p第3个字符继续下一轮匹配
		// 多次 : 第1个字符匹配，从s第2个字符与p继续下一轮匹配
		return (isMatch(s, p.substr(2)) || (first_match && isMatch(s.substr(1), p)));
	}
	else {
		//未匹配到 '*'，继续普通匹配
		return first_match && isMatch(s.substr(1), p.substr(1));
	}
}
